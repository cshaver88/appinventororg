
    <section data-type="chapter" data-pdf-bookmark="Chapter 16. Programming Your App’s Memory" id="programming_your_appapostrophes_memory">
<h1>Programming Your App’s Memory</h1>

<p><em>Just as people need to remember things, so do apps. This chapter examines how you can program an app to remember information.</em></p>

<p><em>When someone tells you the phone number of a pizza place, your brain stores it in a memory slot. If someone calls out some numbers for you to add, you store the numbers and intermediate results in a memory slot. In such cases, you are not fully conscious of how your brain stores information or recalls it.</em></p>

<p><em>An app has a memory as well, but its inner workings are far less mysterious than those of your brain. In this chapter, you’ll learn how to set up an app’s memory, how to store information in it, and how to retrieve that information at a later time.</em></p>

<div class="informalfigure"><img alt="Programming Your Apps" src="/assets/img/bookChapters/v16.png"/></div>

<section data-type="sect1" data-pdf-bookmark="Named Memory Slots" id="named_memory_slots">
<h1>Named Memory Slots</h1>

<p>An app’s memory consists of a set of <em>named memory slots</em>. Some of these memory slots are created when you drag a component into your app; these slots are called <em>properties</em>. You can also define named memory slots that are not associated with a particular component; these are called <em>variables</em>. Whereas properties are typically associated with what is visible in an app, variables can be thought of as the app’s hidden “scratch” memory. </p>
</section>

<section data-type="sect1" data-pdf-bookmark="Properties" id="properties">
<h1>Properties</h1>

<p>You the user of an app can see visible components like buttons, textboxes, and labels. But internally, each component is completely defined by a set of properties. The values stored in the memory slots of each property determine how the component appears.</p>

<p>You set the values of properties directly in the Component Designer. For instance, <a data-type="xref" href="#modifying_the_memory_slots_in_the_proper">Figure 16-1</a> shows the panel for modifying the properties of a <strong>Canvas </strong>component.</p>

<p>The <strong>Canvas</strong> component has numerous properties of various types. For instance, the <strong>BackgroundColor</strong> and <strong>PaintColor</strong> are memory slots that hold a color. The <strong>BackgroundImage</strong> holds a filename <em>(kitty.png)</em>. The <strong>Visible</strong> property holds a <em>Boolean</em> value (true or false, depending on whether the box is checked). The <strong>Width</strong> and <strong>Height</strong> slots hold a number or a special designation (e.g., “Fill parent”).</p>

<p>When you set a property in the Component Designer, you are specifying the initial value of the property-- its value when the app first begins. Property values can also be changed as the app runs, with blocks. But the values shown in the Component Designer, like in <a data-type="xref" href="#modifying_the_memory_slots_in_the_proper">Figure 16-1</a>, don’t change-- these always show only the initial values. This can be confusing as you test an app-- the current value of the app’s properties are not visible.</p>

<figure id="modifying_the_memory_slots_in_the_proper"><img alt="Modifying the memory slots in the property form to change the app’s appearance" src="/assets/img/bookChapters/v16-1a.png"/>
<figcaption>You can set component properties in the Designer. You are setting the initial values of the properties (they don’t show the current values as an app runs).</figcaption>
</figure>
</section>

<section data-type="sect1" data-pdf-bookmark="Defining Variables" id="defining_variables">
<h1>Defining Variables</h1>

<p>Like properties, variables are named memory slots, but they are not associated with a particular component. You define a variable when your app needs to remember something that is not being stored within a component property. For example, a game app might need to remember what level the user has reached. If the level number were going to appear in a <strong>Label</strong> component, you might not need a variable, because you could just store the level in the <strong>Text</strong> property of the <strong>Label</strong> component. But if the level number is not something the user will see, you’d define a variable to store it.</p>

<p>The Presidents Quiz (<a data-type="xref" href="ch08.html#presidents_quiz">Chapter 8</a>) is another example of an app that needs a variable. In that app, only one question of the quiz should appear at a time in the user interface, yet the quiz has many questions (most of which are kept hidden from the user at anytime). Thus, you need to define a variable to store the list of questions.</p>

<p>Whereas properties are created automatically when you drag a component into the Designer, variables are defined explicitly in the Blocks Editor by dragging out an <strong>initialize global variable</strong> block. You can name the variable by clicking the text “name” within the block, and you can specify an initial value for it by dragging out a <strong>number</strong>, <strong>text</strong>, <strong>color</strong>, or <strong>make a list</strong> block and plugging it in. Here are the steps you’d follow to create a variable called <strong>score</strong> with an initial value of 0:</p>

<ol>
	<li>
	<p>Drag the <strong>initialize global variable</strong>  from the <strong>Variables </strong>drawer in the Built-In blocks.</p>

	<div class="informalfigure" id="initialize_global_name"><img alt="initialize global name" src="/assets/img/bookChapters/v16-2.png"/></div>
	</li>
	<li>
	<p>Change the name of the variable by clicking on the text “variable” and typing “score”, as illustrated in <a data-type="xref" href="#initialize_global_score">???</a>.</p>

	<div class="informalfigure" id="initialize_global_score"><img alt="initialize global score" src="/assets/img/bookChapters/v16-3.png"/></div>
	</li>
	<li>
	<p>Set the initial value of the variable by dragging out a number block from the Math drawer and plugging it into the variable definition. <img alt="initialize global score to 0" src="/assets/img/bookChapters/v16-5.png"/></p>
	</li>
</ol>

<p>When you define a variable, you tell the app to set up a named memory slot for storing a value. These memory slots, as with properties, are not visible to the user as the app runs.</p>

<p>The initialization block you plug in specifies the value that should be placed in the slot when the app begins. Besides initializing with numbers or text, you can also initialize the variable with a <strong>make a list</strong> or <strong>create empty list</strong> block. This tells the app that the variable will store a list of memory slots instead of a single value. To learn more about lists, see <a data-type="xref" href="ch19.html#programming_lists_of_data">Chapter 19</a>.</p>
</section>

<section data-type="sect1" data-pdf-bookmark="Setting and Getting a Variable" id="setting_and_getting_a_variable">
<h1>Setting and Getting a Variable</h1>

<p>When you define a variable, App Inventor creates two blocks for it, a <em>set</em> and a <em>get</em>. You can access these blocks by hovering over the variable name in the initialization block as shown in <a data-type="xref" href="#initialization_block_contains_set_and_ge">Figure 16-2</a>.</p>

<figure id="initialization_block_contains_set_and_ge"><img alt="The initialization block contains set and get blocks for that variable" src="/assets/img/bookChapters/v16-6.png"/>
<figcaption>The initialization block contains set and get blocks for that variable</figcaption>
</figure>

<p>The <strong>set global to</strong> block lets you modify the value stored in the variable. For instance, the blocks in <a data-type="xref" href="#placing_a_number_5_into_the_variable_sco">Figure 16-3</a> place a 5 in the variable <strong>score</strong>. The term “global” in the <strong>set global score to</strong> block refers to the fact that the variable can be used in all of the program’s event handlers and procedures. The newest version of App Inventor allows you to also define variables that are “local” to a particular procedure or event handler.</p>

<figure id="placing_a_number_5_into_the_variable_sco"><img alt="Placing a number 5 into the variable score" src="/assets/img/bookChapters/v16-7.png"/>
<figcaption>Placing a number 5 into the variable score</figcaption>
</figure>

<p>The block labeled <strong>get global score</strong> helps you retrieve the value of a variable. For instance, if you wanted to check if the value inside the memory slot was greater than 100, you’d plug the <strong>get global score</strong> block into an <strong>if</strong> test, as demonstrated in <a data-type="xref" href="#using_the_global_score_block_to_get_the">Figure 16-4</a>.</p>

<figure id="using_the_global_score_block_to_get_the"><img alt="Using the global score block to get the value stored in the variable" src="/assets/img/bookChapters/v16-8.png"/>
<figcaption>Using the global score block to get the value stored in the variable</figcaption>
</figure>
</section>

<section data-type="sect1" data-pdf-bookmark="Setting a Variable to an Expression" id="setting_a_variable_to_an_expression">
<h1>Setting a Variable to an Expression</h1>

<p>You can put simple values like 5 into a variable, but often you’ll set the variable to a more complex <em>expression</em> (expression is the computer science term for a formula). For example, when the user clicks Next to get to the next question in a quiz app, you’ll need to set the <strong>currentQuestion</strong> variable to <em>one more than its current value</em>. When someone loses ten points in a game app, you need to modify the <strong>score</strong> variable to <em>10 less than its current value</em>. In a game like MoleMash (<a data-type="xref" href="ch03.html#molemash">Chapter 3</a>), you change the horizontal <em>(x)</em> location of the mole to <em>a random position within a canvas</em>. You’ll build such expressions with a set of blocks that plug into a <strong>set global to</strong> block.</p>
</section>

<section data-type="sect1" data-pdf-bookmark="Incrementing a Variable" id="incrementing_a_variable">
<h1>Incrementing a Variable</h1>

<p>Perhaps the most common expression is for <em>incrementing</em> a variable, or setting a variable based on its own current value. For instance, in a game, when the player scores a point, the variable <strong>score</strong> can be incremented by 5. <a data-type="xref" href="#incrementing_the_variable_score_by_1">Figure 16-5</a> shows the blocks to implement this behavior.</p>

<figure id="incrementing_the_variable_score_by_1"><img alt="Incrementing the variable score by 1" src="/assets/img/bookChapters/v16-9.png"/>
<figcaption>Incrementing the variable score by 5</figcaption>
</figure>

<p>If you can understand these kinds of blocks, you’re well on your way to becoming a programmer. You read these blocks as “set the score to five more than it already is,” which is another way to say <em>increment</em> your variable. The way it works is that the blocks are interpreted inside out, not left to right. So the innermost blocks--the <strong>get global score</strong> and the <strong>number 5</strong> block--are evaluated first. Then the + block is performed and the result is “set” into the variable <strong>score</strong>.</p>

<p>Supposing there were a 10 in the memory slot for score before these blocks, the app would perform the following steps:</p>

<ol>
	<li>Retrieve the 10 from score’s memory slot (evaluate the “get” block).</li>
	<li>Add 5 to it to get 15.</li>
	<li>Place the result, 15, into score’s memory slot (performing the “set”).</li>
</ol>
</section>

<section data-type="sect1" data-pdf-bookmark="Building Complex Expressions" id="building_complex_expressions">
<h1>Building Complex Expressions</h1>

<p>In the Math drawer (<a data-type="xref" href="#blocks_contained_in_the_math_drawer">Figure 16-6</a>), App Inventor provides a wide range of mathematical functions similar to those you’d find in a spreadsheet or calculator.</p>

<figure id="blocks_contained_in_the_math_drawer"><img alt="The blocks contained in the Math drawer" src="/assets/img/bookChapters/v16-10a.png"/> <img alt="The blocks contained in the Math drawer" src="/assets/img/bookChapters/v16-10b.png"/> <img alt="The blocks contained in the Math drawer" src="/assets/img/bookChapters/v16-10c.png"/>
<figcaption>The blocks contained in the Math drawer</figcaption>
</figure>

<p>You can use these blocks to build a complex expression and then plug them in as the <em>righthand-side expression</em> of a <strong>set global to</strong> block. For example, to move an image sprite to a random column within the bounds of a canvas, you’d configure an expression consisting of a multiply (*) block, a subtract (-)block, a <strong>Canvas.Width</strong> property, an <strong>ImageSprite1.Width</strong> property, and a <strong>random fraction</strong> block, as illustrated in <a data-type="xref" href="#you_can_use_math_blocks_to_build_complex">Figure 16-7</a>.</p>

<figure id="you_can_use_math_blocks_to_build_complex"><img alt="You can use math blocks to build complex expressions like this one" src="/assets/img/bookChapters/v16-11.png"/>
<figcaption>You can use Math blocks to build complex expressions like this one</figcaption>
</figure>

<p>As with the increment example in the previous section, the blocks are interpreted by the app in an inside-out fashion. Supposing the <strong>Canvas</strong> has a <strong>Width</strong> of 300 and the <strong>ImageSprite</strong> has a <strong>Width</strong> of 50, the app would perform the following steps:</p>

<ol>
	<li>Retrieve the 300 and the 50 from the memory slots for Canvas1.Width and ImageSprite.Width, respectively.</li>
	<li>Subtract: 300 – 50 = 250.</li>
	<li>Call the random fraction function to get a number between 0 and 1 (say, .5).</li>
	<li>Multiply: 250 * .5 = 125.</li>
	<li>Place the 125 into the memory slot for the ImageSprite1.X property.</li>
</ol>
</section>

<section data-type="sect1" data-pdf-bookmark="Displaying Variables" id="displaying_variables">
<h1>Displaying Variables</h1>

<p>When you modify a component property, as in the preceding example, the user interface is directly affected. This is not true for variables; changing a variable has no direct effect on the app’s appearance. If you just incremented a variable score but didn’t modify the user interface in some other way, the user would never know there was a change. It’s like the proverbial tree falling in the forest: if nobody was there to hear it, did it really happen?</p>

<p>Sometimes you do not want to immediately manifest a change to the user interface when a variable changes. For instance, in a game you might track statistics (e.g., missed shots) that will only appear when the game ends.</p>

<p>This is one of the advantages of storing data in a variable as opposed to a component property: it allows you to show just the data you want when you want to show it. It also allows you to separate the computational part of your app from the user interface, making it easier to change that user interface later.</p>

<p>For example, with a game you could store the score directly in a <strong>Label</strong> or in a variable. If you store it in a <strong>Label</strong>, you’d increment the <strong>Label</strong>’s <strong>Text</strong> property when points were scored, and the user would see the change directly. If you stored the score in a variable and incremented the variable when points were scored, you’d need to include blocks to also move the value of the variable into a label.</p>

<p>However, if you decided to change the app to display the score in a different manner, say with a colored slider, the variable solution would be easier to change. You wouldn’t need to modify all the places that change the score; you’d only need to modify the blocks that displayed the score.</p>
</section>

<section data-type="sect1" data-pdf-bookmark="Local Variables" id="idp4618832">
<h1>Local Variables</h1>

<p>The variables described in this chapter thus far are <em>global</em> variables and you define them with an <strong>initialize global to</strong> block. The “global” refers to the fact that the variable can be used in all event handlers and procedures.</p>

<p>App Inventor now allows you to also define <strong>local</strong> variables, that is, variables whose use is restricted to a single event handler or procedure, as in <a data-type="xref" href="#local_init">Figure 16-8</a></p>

<figure id="local_init"><img alt="local variable initialization" src="/assets/img/bookChapters/v16-locals.png"/>
<figcaption>You can define a variable with resticted (local) scope.</figcaption>
</figure>
If the variable is only needed in one place, it is a good idea to define it as a local instead of a global. By doing so, you limit the dependencies in your app and ensure that you won’t mistakenly modify a variable. Think of a local variable like the private memory in your brain--you certainly don’t want other brains to have access to it!</section>

<section data-type="sect1" data-pdf-bookmark="Summary" id="summary-id00132">
<h1>Summary</h1>

<p>When an app is launched, it begins executing its operations and responding to events that occur. When responding to events, the app sometimes needs to remember things. For a game, this might be each player’s score or the direction in which an object is moving.</p>

<p>Your app remembers things within component properties, but when you need additional memory slots not associated with a component, you can define variables. You can store values into a variable and retrieve the current value, just like you do with properties.</p>

<p>As with property values, variable values are not visible to the end user. If you want the end user to see the information stored in a variable, you add blocks that display that information in a label or another user interface component.</p>
</section>
</section>
